package ${packageName};

import android.app.Activity;
import android.text.Editable;
import android.text.TextWatcher;
import android.widget.EditText;

import utils.Observer;
import utils.State;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;

public class ${className}ViewBinding
{
     private EditText editText;
     private ArrayList<State> states;

     public ${className}ViewBinding(Activity activity)
     {
        states = new ArrayList<>();

        HashMap<Integer, String> stateMap = new HashMap<Integer, String>();
        String mappings = ${mappings};
        mappings = mappings.substring(1, mappings.length() - 1);
        String[] values = mappings.split(",");
        for(String value : values)
        {
          String[] map = value.split("=");
          stateMap.put(Integer.valueOf(map[0]), map[1]);
        }

        for(Integer viewId : stateMap.keySet())
        {
            String name = stateMap.get(viewId);
            try
            {
                Field field = activity.getClass().getField(name);
                State<String> value = (State<String>) field.get(activity);
                states.add(value);
                editText = (EditText) activity.findViewById(viewId);
                editText.setText(value.getValue());
                editText.addTextChangedListener(new EditTextBinder(value));
            }
            catch(NoSuchFieldException | IllegalAccessException e)
            {
                e.printStackTrace();
            }
        }
     }

     public void observe()
     {
        for(State state : states)
            state.observe(stringObserver);
     }

     public void unObserve()
     {
       for(State state : states)
           state.unObserve(stringObserver);
     }

     public class EditTextBinder implements TextWatcher
     {
       private State<String> value;

       public EditTextBinder(State<String> value)
       {
         this.value = value;
       }

       @Override
       public void beforeTextChanged(CharSequence s, int start, int count, int after)
       {
       }

       @Override
       public void onTextChanged(CharSequence s, int start, int before, int count)
       {
       }

       @Override
       public void afterTextChanged(Editable s)
       {
            value.setValue(s.toString());
       }
     }

     public Observer<String> stringObserver = new Observer<String>()
     {
        @Override
		public void onChange(String value)
	    {
            unObserve();
            int cursorPosition = editText.getSelectionStart();
            if(cursorPosition == editText.length())
                cursorPosition = -1;
            editText.setText(value);
            if(cursorPosition == -1)
                cursorPosition = editText.length();
            try
    	    {
    	        editText.setSelection(cursorPosition);
    		}
    		catch(IndexOutOfBoundsException e)
    		{
                editText.setSelection(editText.length());
    		}
            observe();
	    }
     };
}
